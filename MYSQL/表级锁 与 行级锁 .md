好的，我们来系统讲解 **MySQL 锁机制，尤其是表级锁**，并区分常见的锁类型和使用场景。

---

# 1️⃣ MySQL 锁的分类

MySQL 锁主要分为 **行级锁（Row-level）** 和 **表级锁（Table-level）**，不同存储引擎实现方式不同：

| 分类  | 说明                   | 适用引擎                     |
| --- | -------------------- | ------------------------ |
| 表级锁 | 锁整个表，操作效率低但开销小       | MyISAM、MEMORY、InnoDB（可选） |
| 行级锁 | 只锁行，开销大但并发高          | InnoDB                   |
| 页级锁 | 锁一页数据（16KB/8KB），较少使用 | 少数存储引擎                   |

> 注意：InnoDB 支持表级锁，但默认使用行级锁，MyISAM 默认是表级锁。

---

# 2️⃣ 表级锁（Table Lock）详解

表级锁是 **对整张表加锁**，通常有两种类型：

### 🔹 2.1 共享锁（S-lock / READ LOCK）

* 多个事务可以同时对表加共享锁。
* 用于 **只读操作**。
* 示例：

```sql
LOCK TABLES mytable READ;

-- 执行查询
SELECT * FROM mytable;

UNLOCK TABLES;
```

* 期间 **不能进行写操作**（INSERT/UPDATE/DELETE），否则会等待。

### 🔹 2.2 排他锁（X-lock / WRITE LOCK）

* 一次只能有一个事务对表加排他锁。
* 用于 **写操作**。
* 示例：

```sql
LOCK TABLES mytable WRITE;

-- 执行写操作
INSERT INTO mytable VALUES(1,'a');

UNLOCK TABLES;
```

* 期间 **其他事务不能读也不能写**。

---

# 3️⃣ 表级锁特性

| 特性   | 说明                                 |
| ---- | ---------------------------------- |
| 粒度大  | 锁住整张表，阻塞其他事务                       |
| 开销小  | 不像行锁需要维护索引和锁信息                     |
| 并发低  | 多事务写操作时容易阻塞                        |
| 自动释放 | MySQL 会在事务提交或 `UNLOCK TABLES` 时释放锁 |

---

# 4️⃣ 使用场景

1. **MyISAM** 存储引擎

   * 默认表级锁
   * 高速读操作可共享锁
   * 写操作会阻塞其他操作

2. **InnoDB** 存储引擎

   * 默认行级锁
   * 可以用 `LOCK TABLES mytable WRITE` 强制表级锁
   * 常用于批量写入或维护表完整性

---

# 5️⃣ 表级锁与事务隔离关系

* 表级锁在 **事务隔离**中主要影响并发访问。
* 共享锁允许多读不允许写。
* 排他锁会阻塞其他事务的读写。
* 事务提交前加锁的表，其他事务会等待锁释放。

---

# 6️⃣ 示例：表级锁使用

```sql
-- 事务 1
LOCK TABLES mytable WRITE;
INSERT INTO mytable VALUES(1,'a');
-- 事务 2 执行 SELECT * 会阻塞，直到事务 1 UNLOCK
UNLOCK TABLES;

-- 事务 3
LOCK TABLES mytable READ;
SELECT * FROM mytable;
-- 事务 4 无法写
UNLOCK TABLES;
```

---

如果你愿意，我可以帮你画一张 **表级锁的并发示意图**，显示共享锁与排他锁如何影响读写，非常直观。

你希望我画吗？
