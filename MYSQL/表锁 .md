好的，我们来详细讲解 **MySQL 表锁（Table Lock）** 的使用，包括语法、场景和注意事项。

---

## 1️⃣ 表锁定义

**表锁（Table Lock）**：对整张表加锁，阻止其他事务对该表进行特定操作，保证当前会话操作安全。

* **粒度大**：一旦加锁，整张表受影响
* **效率低**：并发性能比行锁低
* **存储引擎**：

  * **MyISAM** 默认使用表锁
  * **InnoDB** 支持，但通常使用行锁 + MVCC，表锁一般用于特殊场景

---

## 2️⃣ 表锁语法

### 2.1 加锁

```sql
LOCK TABLES table_name [AS alias] lock_type [, ...];
```

* `lock_type` 可选：

  * `READ`：读锁（共享锁）

    * 其他事务可以读取
    * 禁止写入
  * `WRITE`：写锁（排他锁）

    * 其他事务不能读也不能写

#### 示例

```sql
-- 对 t 表加写锁
LOCK TABLES t WRITE;

-- 对 t 表加读锁
LOCK TABLES t READ;
```

---

### 2.2 解锁

```sql
UNLOCK TABLES;
```

* 释放当前会话对所有表的锁
* 会话断开连接时，锁会自动释放

---

## 3️⃣ 表锁的行为

| 当前事务锁 | 其他事务操作 | 允许/阻塞    |
| ----- | ------ | -------- |
| READ  | READ   | ✅ 允许并发读取 |
| READ  | WRITE  | ❌ 阻塞写操作  |
| WRITE | READ   | ❌ 阻塞读操作  |
| WRITE | WRITE  | ❌ 阻塞写操作  |

---

## 4️⃣ 使用场景

1. **MyISAM 存储引擎**：

   * 默认使用表锁，写操作会锁整张表
   * 适合 **读多写少** 场景
2. **InnoDB**：

   * 表锁通常用于：

     * 大量写操作需要阻塞所有读写，保证批量操作原子性
     * 数据导出或备份时防止表被修改
3. **批量数据操作**：

   * 加写锁后批量 `INSERT/UPDATE/DELETE`，防止其他事务干扰

---

## 5️⃣ 示例

```sql
-- 加写锁
LOCK TABLES t WRITE;

-- 批量操作
INSERT INTO t VALUES(1, 'a');
DELETE FROM t WHERE id=2;

-- 解锁
UNLOCK TABLES;
```

> 说明：加写锁期间，其他会话无法对表 t 进行任何读写操作

---

## 6️⃣ 注意事项

1. **锁是会话级别**：不同会话的锁互不干扰
2. **死锁风险低**，但并发性能差
3. **InnoDB 推荐使用行锁 + MVCC**，除非特殊场景才用表锁
4. **加锁后要及时解锁**，避免阻塞其他事务

---

如果你需要，我可以画一张 **表锁 READ/WRITE 对其他事务读写影响的示意图**，直观理解表锁行为。

你希望我画吗？